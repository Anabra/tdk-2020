\documentclass[main.tex]{subfiles}
\begin{document}

  In this chapter we discuss logic defined program analyses for GRIN. First, we show how the GRIN language can be modeled by mathematical relations. Then, through a simple example, we illustrate how program analyses can be defined via recursive relations in Datalog. Finally, --- using the mentioned Datalog model --- we present a logic-based formalization of the created-by and liveness data-flow analyses.

	\section{Motivation}
	
	Static program analysis specifications are usually defined in a declarative manner through mutually recursive relations. Their implementations however, are often given in an imperative style in order to maximize performance. This discrepancy between the denotational and operational semantics leads to very complicated hand-written implementations.
	
	Fortunately, many static program analysis frameworks \cite{doop, cclyzer, souffle-2} already addressed this issue. These tools use Datalog --- a declarative logic programming language --- as the surface language for defining analyses, then the Datalog program is automatically compiled to efficient imperative code. Datalog allows the programmer to define mutually recursive relations which then are evaluated to a fixed point. This approach facilitates the implementation of complex program analyses by allowing the programmer to focus on the high level specification, meanwhile guaranteeing competitive performance.

  \section{Datalog model of GRIN} \label{sec:datalog-model}
  
  In order to define Datalog analyses for GRIN, the first thing we need need is a Datalog model of the language itself. That is, a declarative, relation-based representation of GRIN programs, that captures the same information that an abstract syntax tree would. In fact, it is possible to define a model from which the original program can be recreated. This suggests an isomorphism between the AST and the Datalog model. However, for our purposes a less precise model is sufficient. 
  
  The rules below define the Datalog model of the GRIN IR. The rules are purely syntactic, and consist of a GRIN program snippet and the corresponding Datalog relation(s). The snippets can be thought of as patterns, which are matched against the current node during the traversal of the abstract syntax tree. If they match, then the relation(s) below the line are "emitted". Hence, these rules are called \emph{emission rules}. The emitted relations will serve as the input relations for the analyses.
  
  Some of the emission rules contain templates, special functions or partial program snippets. Templates are surrounded by angled brackets and they should be interpreted as holes for specific program elements. For example, the template \pilcode{<lit>} marks an arbitrary literal. There are three special functions: $\tau$, $\pi$ and $\epsilon$. The expression $\tau(x)$ denotes the type of $x$, $\pi(x)$ denotes the position (zero-based index) of $x$ and $\epsilon(x)$ denotes whether $x$ is effectful. $\tau$ is used to determine the types of literals, $\pi$ is used to determine the position of an argument or parameter (of a node or function respectively) and $\epsilon$ is used to determine whether an external is side-effecting or not. $\epsilon(pure)$ is false, $\epsilon(effectful)$ is true. Finally, \dots in partial program snippets are used to denote syntactically valid, but irrelevant parts of the program. In some cases they are used to denote missing arguments or case alternatives, in which case the rule should be applied to all arguments and case alternatives.
  
  Furthermore we use the terminology "function parameter" and "function argument" to mean formal and actual function arguments respectively. Also, "node parameter" means the variable arguments in an @pattern (always on the left-hand side), and "node argument" means the variable in a node value (always on the right-hand side).
  
  \subsection{Simple instructions}
  
  These rules are responsible for handling the syntactically simple instructions of GRIN. These are literal assignment (\textsc{ER-Lit}), variable copying (\textsc{ER-Move}), store (\textsc{ER-Store}), fetch (\textsc{ER-Fetch}) and update (\textsc{ERF-Update}). The rules can be seen in Figure~\ref{fig:er-simple}. 

  \begin{figure}[h]
    \begin{mathpar}
    \EmissionRule{\LitAssign{k}{\tau(lit)}{lit}}
                 {\pilcode{k <- pure <lit>}}
                 {ER-Lit}
    \and
    \EmissionRule{\Move{y}{x}}
                {\pilcode{y <- pure x}}
                {ER-Move}
    \and
    \EmissionRule{\Store{p}{n}}
                {\pilcode{p <- store n}}
                {ER-Store}
    \and
    \EmissionRule{\Fetch{n}{p}}
                {\pilcode{n <- fetch p}}
                {ER-Fetch}
    \and
    \EmissionRule{\Update{x}{p}{n}}
                {\pilcode{x <- update p n}}
                {ER-Update}
    \end{mathpar}
  \caption{Emission rules for simple instructions}
  \label{fig:er-simple}
  \end{figure}

	\subsection{Function calls and node values}
	
	The rules \textsc{ER-Call}, \textsc{ER-Node} and \textsc{ER-AsPat} handle function calls, node value creation and @patterns respectively. They can be seen in Figure~\ref{fig:er-funcalls-nodevals}.

	\begin{figure}[h]
		\begin{mathpar}
		  \EmissionRule{\Call{r}{f} \\\\
                    \CallArgument{r}{\pi(x)}{x}}
                    {\pilcode{r <- f ... x ...}}
                    {ER-Call}
      \\\\\\
      \EmissionRule{\Node{n}{tag} \\\\
                    \NodeArgument{n}{\pi(x)}{x}}
                    {\pilcode{n <- pure (tag ... x ...)}}
                    {ER-Node}
      \and
      \EmissionRule{\NodePattern{n}{tag}{m} \\\\
                    \NodeParameter{n}{\pi(x)}{x}}
                    {\pilcode{(tag ... x ...) @ n <- pure m}}
                    {ER-AsPat}
		\end{mathpar}
	\caption{Emission rules for function calls and node values}
	\label{fig:er-funcalls-nodevals}
	\end{figure}

	\subsection{Case expressions}
	
	These rules handle case expression. \textsc{ER-Case} relates the case expression to a name; \textsc{ER-AltRetVal} relates the return value of a binding sequence to the encompassing alternative's name; \textsc{ER-AltLit}, \textsc{ER-AltDef} and \textsc{ER-AltNode} represent the literal, default and node-valued case alternatives. The rules can be seen in Figure~\ref{fig:er-case}.

  \begin{figure}[h]
    \begin{mathpar}
    \EmissionRule{\Case{r}{s}}
                {\pilcode{r <- case s of ...}}
                {ER-Case}
    \and
    \EmissionRuleL{\ReturnValue{alt}{x}}
                  {\pilcode{... @ alt -> } \\\\
                  \\ \dots \\\\
                  \\ \pilcode{pure x}}
                  {ER-AltRetVal}
    \and
    \EmissionRuleL{\AltLiteral{r}{alt}{lit}}
                {\pilcode{r <- case s of} \\\\
                  \\ \pilcode{<lit> @ alt -> ...}}
                {ER-AltLit}
    \and
    \EmissionRuleL{\AltDefault{r}{alt}}
                {\pilcode{r <- case s of} \\\\
                  \\ \pilcode{\#default @ alt -> ...}}
                {ER-AltDef}
    \and
    \EmissionRuleL{\hspace{1.1cm} \Alt{r}{alt}{tag} \\\\
                  \AltParameter{r}{tag}{\pi(x)}{x}}
                {\pilcode{r <- case s of} \\\\
                  \\ \pilcode{(tag ... x ...) @ alt -> ...}}
                {ER-AltNode}
    \end{mathpar}
  \caption{Emission rules for case expressions}
  \label{fig:er-case}
  \end{figure}

	\subsection{Function definitions}
	
	\textsc{ER-Fun} relates function parameters to the function's name, and \textsc{ER-FunRetVal} relates the return value of a binding sequence to the encompassing function's name. \textsc{ER-Ext} handles external declarations, and \textsc{ER-Entry} denotes the main entry point of the program.

	\begin{figure}[h]
		\begin{mathpar}
    \EmissionRule{\FunctionParameter{f}{\pi(x)}{x}}
               {\pilcode{f ... x ... = ...}}
               {ER-Fun}
    \and
    \EmissionRuleL{\ReturnValue{f}{x}}
                {\pilcode{f ... =} \\\\
                \\ \dots \\\\
                \\ \pilcode{pure x}}
                {ER-FunRetVal}
    \and
    \EmissionRuleL{\External{f}{\epsilon(effect)}{retTy} \\\\
                  \ExternalParam{f}{\pi(ty)}{ty}}
                {\pilcode{external <effect>} \\\\
                \\ \pilcode{f :: ... -> ty -> ... -> retTy}}
                {ER-Ext}
    \and
    \EmissionRule{\EntryPoint{main}}
                { }
                {ER-Entry}
		\end{mathpar}
		\caption{Emission rules for functions}
		\label{fig:er-fundefs}
	\end{figure}


  \section{A simple analysis example}

  \begin{figure}[h]
    \begin{mathpar}
      \InferRule{\Store{v}{i}}
                {\Heap{v}{i}}
                {H-1}
      \and
      \InferRule{\Update{\any}{p}{val} \\\\
                \CreatedBy{p}{p'} \\\\
                \Heap{p'}{\any}}
                {\Heap{p'}{val}}
                {H-2}
    \end{mathpar}

  \caption{Rules of the Heap analysis}
  \end{figure}


  \section{Created-by analysis}

  \begin{figure}[h]
    \begin{mathpar}
    \InferRule{\LitAssign{v}{\any}{\any}}
              {\CreatedBy{v}{v}}
              {CBy-1}
    \and
    \InferRule{\Node{n}{\any}}
              {\CreatedBy{n}{n}}
              {CBy-2}
    \and
    \InferRule{\Store{p}{\any}}
              {\CreatedBy{p}{p}}
              {CBy-3}
    \and
    \InferRule{\Update{v}{\any}{\any}}
              {\CreatedBy{v}{v}}
              {CBy-4}
    \and
    \InferRule{\LitAssign{v}{\any}{\any}}
              {\CreatedBy{v}{v}}
              {CBy-5}
    \end{mathpar}
  \caption{Simple rules of the CreatedBy analysis}
  \end{figure}

  \begin{figure}[h]
    \begin{mathpar}
    \InferRule{\Move{v}{n} \\\\
                \CreatedBy{n}{n'}}
                {\CreatedBy{v}{n'}}
                {CBy-6}
		\and
		\InferRule{\FunctionParameter{\any}{\any}{p} \\\\
							\CreatedBy{v_1}{p} \\\\
							\CreatedBy{p}{v_2}}
							{\CreatedBy{v_1}{v_2}}
							{CBy-7}
		\and
		\DatalogRule{\CreatedBy{v}{n'}}
								{\Fetch{v}{p} \\\\
									\CreatedBy{p}{p'} \\\\
									\Heap{p'}{n} \\\\
									\CreatedBy{n}{n'}}
									{CBy-8}
		\and
		\DatalogRule{\CreatedBy{x}{arg'}}
								{\CallArgument{r}{i}{arg} \\\\
								\Call{r}{f} \\\\
								\FunctionParameter{f}{i}{x} \\\\
								\CreatedBy{arg}{arg'}}
								{CBy-9}
		\and
		\DatalogRule{\CreatedBy{r}{v'}}
								{\Call{r}{f} \\\\
								\ReturnValue{f}{v} \\\\
								\CreatedBy{v}{v'}}
								{CBy-10}
		%TODO: NodeCreatedBy
		\and
		\DatalogRule{\CreatedBy{u}{arg'}}
								{\NodePattern{v}{tag}{n} \\\\
								\NodeParameter{v}{i}{u} \\\\
								\CreatedBy{n}{n'} \\\\
								\Node{n'}{tag} \\\\
								\NodeArgument{n'}{i}{arg} \\\\
								\CreatedBy{arg}{arg'}}
								{CBy-11}
		\and
		\DatalogRule{\CreatedBy{v}{n'}}
								{\NodePattern{v}{\any}{n} \\\\
								\CreatedBy{n}{n'}}
								{CBy-12}
    \end{mathpar}
  \caption{Some recursive rules of the CreatedBy analysis}
  \end{figure}

  \begin{figure}[h]
    	\begin{mathpar}
      \DatalogRule{\CreatedBy{alt}{scrut'}}
                  {\Case{r}{scrut} \\\\
                  \AltLiteral{r}{alt}{\any} \\\\
                  \CreatedBy{scrut}{scrut'}}
                  {CBy-13}
      \and
      \DatalogRule{\CreatedBy{alt}{scrut'}}
                  {\Case{r}{scrut} \\\\
                  \AltLiteral{r}{alt}{tag} \\\\
                  \CreatedBy{scrut}{scrut'} \\\\
                  \Node{scrut'}{tag}}
                  {CBy-14}
      \and
      \DatalogRule{\CreatedBy{alt}{scrut'}}
                  {\Case{r}{scrut} \\\\
                  \AltDefault{r}{alt} \\\\
                  \CreatedBy{scrut}{scrut'}}
                  {CBy-15}
      \and
      % TODO: shorter name for altParam
      % TODO: shorter name for nodeArg
      % TODO: PossibleAlt
      \DatalogRule{\CreatedBy{altParam}{nodeArg'}}
                  {\Case{r}{scrut} \\\\
                  \Alt{r}{\any}{tag} \\\\
                  \AltParameter{r}{tag}{i}{altParam} \\\\
                  \CreatedBy{scrut}{scrut'} \\\\
                  \Node{scrut'}{tag} \\\\
                  \NodeArgument{scrut'}{i}{nodeArg} \\\\
                  \CreatedBy{nodeArg}{nodeArg'}}
                  {CBy-16}
      \and
      \DatalogRule{\CreatedBy{r}{v'}}
                  {\Case{r}{scrut} \\\\
                  \Alt{r}{alt}{tag} \\\\
                  \CreatedBy{scrut}{scrut'} \\\\
                  \Node{scrut'}{tag} \\\\
                  \ReturnValue{alt}{v} \\\\
                  \CreatedBy{v}{v'}}
                  {CBy-17}
      % TODO: maybe OR?
      \and
      \DatalogRule{\CreatedBy{r}{v'}}
                  {\Case{r}{\any} \\\\
                  \AltLiteral{r}{alt}{\any} \\\\
                  \ReturnValue{alt}{v} \\\\
                  \CreatedBy{v}{v'}}
                  {CBy-18}
      \and
      \DatalogRule{\CreatedBy{r}{v'}}
                  {\Case{r}{\any} \\\\
                  \AltDefault{r}{alt} \\\\
                  \ReturnValue{alt}{v} \\\\
                  \CreatedBy{v}{v'}}
                  {CBy-19}
    \end{mathpar}
  \caption{Case-related rules of the CreatedBy analysis}
  \end{figure}

  \section{Liveness analysis}

  \begin{figure}[h]

    \begin{mathpar}
		\DatalogRule{\NodeCreatedBy{n}{t}{n'}}
								{\Node{n'}{t} \\\\
								\CreatedBy{v}{v'}}
								{NCBy}
		\and
		\DatalogRule{\PossibleNodeTag{n}{t}}
								{\NodeCreatedBy{n}{t}{\any}}
								{PNT}
		\and
		\DatalogRule{\PossibleAlt{alt}}
								{\AltDefault{\any}{alt}}
								{PA-1}
		\and
		\DatalogRule{\PossibleAlt{alt}}
								{\AltLiteral{\any}{alt}{\any}}
								{PA-2}
		\and
		\DatalogRule{\PossibleAlt{alt}}
								{\Case{r}{scrut} \\\\
								\Alt{r}{alt}{t} \\\\
								\NodeCreatedBy{scrut}{t}{scrut'}}
								{PA-3}
		\and
		\DatalogRule{\PointerOrigin{p}{q}}
								{\Store{q}{\any} \\\\
								\CreatedBy{p}{q}}
								{PO}
		\and
		\DatalogRule{\PossibleLocTag{p}{t}}
								{\Heap{p}{n} \\\\
								\PossibleNodeTag{n}{tag}}
								{PLT}
	  \end{mathpar}
  \caption{Helper relations}
  \end{figure}

  \begin{figure}[h]
    	\begin{mathpar}
      \DatalogRule{\LiveSVal{x}}
                  {\EntryPoint{main} \\\\
                  \ReturnValue{main}{x}}
                  {LS-1}
      \and
      \DatalogRule{\LiveSVal{x}}
                  {\Call{y}{f} \\\\
                  \CallArgument{y}{\any}{x} \\\\
                  \External{f}{true}{\any}}
                  {LS-2}
      \and
      \DatalogRule{\LiveSVal{x}}
              {\LiveSVal{y} \\\\
              \Move{y}{x}}
              {LS-3}
      \and
      % TODO: alt helper relation
      \DatalogRule{\LiveSVal{ret}}
                  {\LiveSVal{res} \\ \PossibleAlt{alt} \\ \ReturnValue{alt}{ret} \\\\
                  (\Alt{res}{alt}{\any} \lor \AltLiteral{res}{alt}{\any} \lor \AltDefault{res}{alt})}
                  {LS-4}
      \and
      \DatalogRule{\LiveSVal{scrut}}
                  {\LiveSVal{alt} \\ \PossibleAlt{alt} \\ \Case{res}{scrut} \\\\
                  (\Alt{res}{alt}{\any} \lor \AltLiteral{res}{alt}{\any} \lor \AltDefault{res}{alt})}
                  {LS-5}
      \and
      \DatalogRule{\LiveFunRetSimple{f}}
                  {\LiveSVal{y} \\\\
                  \Call{y}{f}}
                  {LFS-3}
      \and
      \DatalogRule{\LiveSVal{ret}}
                  {\LiveFunRetSimple{f} \\\\
                  \ReturnValue{f}{ret}}
                  {LS-6}
      \and
      \DatalogRule{\LiveSVal{x}}
                  {\LiveSVal{param} \\\\
                  \FunctionParameter{f}{i}{param} \\\\
                  \Call{y}{f} \\\\
                  \CallArgument{y}{i}{x}}
                  {LS-7}
      \and
      \DatalogRule{\LiveSVal{x}}
                  {\LiveFunRetSimple{f_{ext}} \\\\
                  \External{f_{ext}}{\any}{\any} \\\\
                  \Call{y}{f_{ext}} \\\\
                  \CallArgument{y}{\any}{x}}
                  {LS-8}
      \and
      \DatalogRule{\LiveSVal{x}}
                  {\LiveNodeArg{n}{t}{i} \\\\
                  \Node{n}{t} \\\\
                  \NodeArgument{n}{i}{x}}
                  {LS-9}
	  \end{mathpar}
  \caption{Liveness rules for simple values}
  \end{figure}

  \begin{figure}[h]
    \begin{mathpar}
    \DatalogRule{\LiveNodeArg{n}{t}{i}}
								{\LiveSVal{x} \\\\
								\NodeParameter{as}{i}{x} \\\\
								\NodePattern{as}{t}{n}}
								{LNA-1}
		\and
		\DatalogRule{\LiveNodeArg{n}{t}{i}}
								{\LiveNodeArg{as}{t}{i} \\\\
								\NodePattern{as}{t}{n}}
								{LNA-2}
		\and
		\DatalogRule{\LiveNodeArg{n}{t}{i}}
								{\LiveSVal(x) \\\\
								\NodePattern{as}{t}{n} \\\\
								\NodeParameter{as}{i}{x}}
								{LNA-3}
		\and
		\DatalogRule{\LiveNodeArg{m}{t}{i}}
								{\LiveNodeArg{n}{t}{i} \\\\
								\Move{n}{m}}
								{LNA-4}
    \end{mathpar}
  \caption{Liveness rules for node values}
  \end{figure}

  \begin{figure}[h]
    \begin{mathpar}
    \DatalogRule{\LiveNodeArg{scrut}{t}{i}}
								{\LiveNodeArg{alt}{t}{i} \\\\
								\Case{r}{scrut} \\\\
								\Alt{r}{alt}{t} \\\\
								\AltParameter{r}{t}{i}{\any}}
								{LNA-5}
		\and
		\DatalogRule{\LiveNodeArg{scrut}{t}{i}}
								{\LiveSVal{x} \\\\
								\Case{r}{scrut} \\\\
								\AltParameter{r}{t}{i}{x}}
								{LNA-6}
		\and
		% TODO: maybe NodeCreatedBy?
		\DatalogRule{\LiveNodeArg{ret}{t_{res}}{i}}
								{\LiveNodeArg{res}{t_{res}}{i} \\\\
								\Case{res}{scrut} \\\\
								\Alt{res}{alt}{t_{alt}} \\\\
								\ReturnValue{alt}{ret} \\\\
								\PossibleAlt{alt} \\\\
								\CreatedBy{ret}{ret'} \\\\
								\Node{ret'}{t_{res}}}
								{LNA-7}
		\and
		% TODO: maybe NodeCreatedBy?
		\DatalogRule{\LiveNodeArg{ret}{t_{res}}{i}}
								{\LiveNodeArg{res}{t_{res}}{i} \\\\
								\Case{res}{\any} \\\\
								(\AltLiteral{res}{alt}{\any} \lor \AltDefault{res}{alt}) \\\\
								\ReturnValue{alt}{ret} \\\\
								\CreatedBy{ret}{ret'} \\\\
								\Node{ret'}{t_{res}}}
								{LNA-8}
    \end{mathpar}
  \caption{Liveness rules for case expressions}
  \end{figure}

  \begin{figure}[h]
    \begin{mathpar}
    \DatalogRule{\LiveFunRetNodeArg{f}{t}{i}}
								{\LiveNodeArg{y}{t}{i} \\\\
								\Call{y}{f}}
								{LFN}
		\and
		\DatalogRule{\LiveNodeArg{r}{t}{i}}
								{\LiveFunRetNodeArg{f}{t}{i} \\\\
								\ReturnValue{f}{r}}
								{LNA-9}
		\and
		\DatalogRule{\LiveNodeArg{x}{t}{i}}
								{\LiveNodeArg{param}{t}{i} \\\\
								\FunctionParameter{f}{j}{param} \\\\
								\Call{y}{f} \\\\
								\CallArgument{y}{j}{x}}
								{LNA-10}
    \end{mathpar}
  \caption{Liveness rules for functions}
  \end{figure}

  \begin{figure}[h]
    \begin{mathpar}
    \DatalogRule{\LiveHeapNodeArg{q}{t}{i}}
								{\LiveNodeArg{n}{t}{i} \\\\
								\Fetch{n}{p} \\\\
								\PointerOrigin{p}{q} \\\\
								\PossibleLocTag{q}{t}}
								{LHN}
		\and
		\DatalogRule{\LiveNodeArg{n}{t}{i}}
								{\LiveHeapNodeArg{p}{t}{i} \\\\
								\Store{q}{n} \\\\
								\PointerOrigin{p}{q} \\\\
								\PossibleNodeTag{n}{t}}
								{LNA-11}
		\and
		\DatalogRule{\LiveNodeArg{n}{t}{i}}
								{\LiveHeapNodeArg{q}{t}{i} \\\\
								\Update{\any}{p}{n} \\\\
								\PointerOrigin{p}{q} \\\\
								\PossibleNodeTag{n}{t}}
								{LNA-12}
    \end{mathpar}
  \caption{Liveness rules for heap operations}
  \end{figure}



\end{document}
