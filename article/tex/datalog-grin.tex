\documentclass[main.tex]{subfiles}
\begin{document}

  In this chapter we discuss logic defined program analyses for GRIN. First, we show how the GRIN language can be modeled by mathematical relations. Then, through a simple example, we illustrate how program analyses can be defined via Horn clauses, and finally we present a logic-based formalization of the created-by and liveness data-flow analyses.

  \section{Datalog model of GRIN} \label{sec:datalog-model}
  
  \subsection{Simple instructions}

  \begin{figure}[h]
    \begin{mathpar}
    \EmissionRule{\LitAssign{k}{\tau(lit)}{lit}}
                 {\pilcode{k <- pure <lit>}}
                 {ER-Lit}
    \and
    \EmissionRule{\Move{y}{x}}
                {\pilcode{y <- pure x}}
                {ER-Move}
    \and
    \EmissionRule{\Store{p}{n}}
                {\pilcode{p <- store n}}
                {ER-Store}
    \and
    \EmissionRule{\Fetch{n}{p}}
                {\pilcode{n <- fetch p}}
                {ER-Fetch}
    \and
    \EmissionRule{\Update{x}{p}{n}}
                {\pilcode{x <- update p n}}
                {ER-Update}
    \end{mathpar}
  \caption{Emission rules for simple instructions}
  \end{figure}

	\subsection{Function calls and node values}

	\begin{figure}[h]
		\begin{mathpar}
		  \EmissionRule{\Call{r}{f} \\\\
                    \CallArgument{r}{\pi(x)}{x}}
                    {\pilcode{r <- f ... x ...}}
                    {ER-Call}
      \\\\\\
      \EmissionRule{\Node{n}{tag} \\\\
                    \NodeArgument{n}{\pi(x)}{x}}
                    {\pilcode{n <- pure (tag ... x ...)}}
                    {ER-Node}
      \and
      \EmissionRule{\NodePattern{n}{tag}{m} \\\\
                    \NodeParameter{n}{\pi(x)}{x}}
                    {\pilcode{(tag ... x ...) @ n <- pure m}}
                    {ER-AsPat}
		\end{mathpar}
	\caption{Emission rules for function calls and node values}
	\end{figure}

	\subsection{Case expressions}

  \begin{figure}[h]
    \begin{mathpar}
    \EmissionRule{\Case{r}{s}}
                {\pilcode{r <- case s of ...}}
                {ER-Case}
    \and
    \EmissionRuleL{\ReturnValue{alt}{x}}
                  {\pilcode{... @ alt -> } \\\\
                  \\ \dots \\\\
                  \\ \pilcode{pure x}}
                  {ER-AltRetVal}
    \and
    \EmissionRuleL{\AltLiteral{r}{alt}{lit}}
                {\pilcode{r <- case s of} \\\\
                  \\ \pilcode{<lit> @ alt -> ...}}
                {ER-AltLit}
    \and
    \EmissionRuleL{\AltDefault{r}{alt}}
                {\pilcode{r <- case s of} \\\\
                  \\ \pilcode{\#default @ alt -> ...}}
                {ER-AltDef}
    \and
    \EmissionRuleL{\hspace{1.1cm} \Alt{r}{alt}{tag} \\\\
                  \AltParameter{r}{tag}{\pi(x)}{x}}
                {\pilcode{r <- case s of} \\\\
                  \\ \pilcode{(tag ... x ...) @ alt -> ...}}
                {ER-AltNode}
    \end{mathpar}
  \caption{Emission rules for case expressions}
  \end{figure}

	\subsection{Function definitions}

	\begin{figure}[h]
		\begin{mathpar}
    \EmissionRule{\FunctionParameter{f}{\pi(x)}{x}}
               {\pilcode{f ... x ... = ...}}
               {ER-Fun}
    \and
    \EmissionRuleL{\ReturnValue{f}{x}}
                {\pilcode{f ... =} \\\\
                \\ \dots \\\\
                \\ \pilcode{pure x}}
                {ER-FunRetVal}
    \and
    \EmissionRuleL{\External{f}{\epsilon(effect)}{retTy} \\\\
                  \ExternalParam{f}{\pi(ty)}{ty}}
                {\pilcode{external <effect>} \\\\
                \\ \pilcode{f :: ... -> ty -> ... -> retTy}}
                {ER-Ext}
    \and
    \EmissionRule{\EntryPoint{main}}
                { }
                {ER-Entry}
		\end{mathpar}
		\caption{Emission rules for functions}
	\end{figure}


  \section{A simple analysis example}

  \begin{figure}[h]
    \begin{mathpar}
      \InferRule{\Store{v}{i}}
                {\Heap{v}{i}}
                {H-1}
      \and
      \InferRule{\Update{\any}{p}{val} \\\\
                \CreatedBy{p}{p'} \\\\
                \Heap{p'}{\any}}
                {\Heap{p'}{val}}
                {H-2}
    \end{mathpar}

  \caption{Rules of the Heap analysis}
  \end{figure}


  \section{Created-by analysis}

  \begin{figure}[h]
    \begin{mathpar}
    \InferRule{\LitAssign{v}{\any}{\any}}
              {\CreatedBy{v}{v}}
              {CBy-1}
    \and
    \InferRule{\Node{n}{\any}}
              {\CreatedBy{n}{n}}
              {CBy-2}
    \and
    \InferRule{\Store{p}{\any}}
              {\CreatedBy{p}{p}}
              {CBy-3}
    \and
    \InferRule{\Update{v}{\any}{\any}}
              {\CreatedBy{v}{v}}
              {CBy-4}
    \and
    \InferRule{\LitAssign{v}{\any}{\any}}
              {\CreatedBy{v}{v}}
              {CBy-5}
    \end{mathpar}
  \caption{Simple rules of the CreatedBy analysis}
  \end{figure}

  \begin{figure}[h]
    \begin{mathpar}
    \InferRule{\Move{v}{n} \\\\
                \CreatedBy{n}{n'}}
                {\CreatedBy{v}{n'}}
                {CBy-6}
		\and
		\InferRule{\FunctionParameter{\any}{\any}{p} \\\\
							\CreatedBy{v_1}{p} \\\\
							\CreatedBy{p}{v_2}}
							{\CreatedBy{v_1}{v_2}}
							{CBy-7}
		\and
		\DatalogRule{\CreatedBy{v}{n'}}
								{\Fetch{v}{p} \\\\
									\CreatedBy{p}{p'} \\\\
									\Heap{p'}{n} \\\\
									\CreatedBy{n}{n'}}
									{CBy-8}
		\and
		\DatalogRule{\CreatedBy{x}{arg'}}
								{\CallArgument{r}{i}{arg} \\\\
								\Call{r}{f} \\\\
								\FunctionParameter{f}{i}{x} \\\\
								\CreatedBy{arg}{arg'}}
								{CBy-9}
		\and
		\DatalogRule{\CreatedBy{r}{v'}}
								{\Call{r}{f} \\\\
								\ReturnValue{f}{v} \\\\
								\CreatedBy{v}{v'}}
								{CBy-10}
		%TODO: NodeCreatedBy
		\and
		\DatalogRule{\CreatedBy{u}{arg'}}
								{\NodePattern{v}{tag}{n} \\\\
								\NodeParameter{v}{i}{u} \\\\
								\CreatedBy{n}{n'} \\\\
								\Node{n'}{tag} \\\\
								\NodeArgument{n'}{i}{arg} \\\\
								\CreatedBy{arg}{arg'}}
								{CBy-11}
		\and
		\DatalogRule{\CreatedBy{v}{n'}}
								{\NodePattern{v}{\any}{n} \\\\
								\CreatedBy{n}{n'}}
								{CBy-12}
    \end{mathpar}
  \caption{Some recursive rules of the CreatedBy analysis}
  \end{figure}

  \begin{figure}[h]
    	\begin{mathpar}
      \DatalogRule{\CreatedBy{alt}{scrut'}}
                  {\Case{r}{scrut} \\\\
                  \AltLiteral{r}{alt}{\any} \\\\
                  \CreatedBy{scrut}{scrut'}}
                  {CBy-13}
      \and
      \DatalogRule{\CreatedBy{alt}{scrut'}}
                  {\Case{r}{scrut} \\\\
                  \AltLiteral{r}{alt}{tag} \\\\
                  \CreatedBy{scrut}{scrut'} \\\\
                  \Node{scrut'}{tag}}
                  {CBy-14}
      \and
      \DatalogRule{\CreatedBy{alt}{scrut'}}
                  {\Case{r}{scrut} \\\\
                  \AltDefault{r}{alt} \\\\
                  \CreatedBy{scrut}{scrut'}}
                  {CBy-15}
      \and
      % TODO: shorter name for altParam
      % TODO: shorter name for nodeArg
      % TODO: PossibleAlt
      \DatalogRule{\CreatedBy{altParam}{nodeArg'}}
                  {\Case{r}{scrut} \\\\
                  \Alt{r}{\any}{tag} \\\\
                  \AltParameter{r}{tag}{i}{altParam} \\\\
                  \CreatedBy{scrut}{scrut'} \\\\
                  \Node{scrut'}{tag} \\\\
                  \NodeArgument{scrut'}{i}{nodeArg} \\\\
                  \CreatedBy{nodeArg}{nodeArg'}}
                  {CBy-16}
      \and
      \DatalogRule{\CreatedBy{r}{v'}}
                  {\Case{r}{scrut} \\\\
                  \Alt{r}{alt}{tag} \\\\
                  \CreatedBy{scrut}{scrut'} \\\\
                  \Node{scrut'}{tag} \\\\
                  \ReturnValue{alt}{v} \\\\
                  \CreatedBy{v}{v'}}
                  {CBy-17}
      % TODO: maybe OR?
      \and
      \DatalogRule{\CreatedBy{r}{v'}}
                  {\Case{r}{\any} \\\\
                  \AltLiteral{r}{alt}{\any} \\\\
                  \ReturnValue{alt}{v} \\\\
                  \CreatedBy{v}{v'}}
                  {CBy-18}
      \and
      \DatalogRule{\CreatedBy{r}{v'}}
                  {\Case{r}{\any} \\\\
                  \AltDefault{r}{alt} \\\\
                  \ReturnValue{alt}{v} \\\\
                  \CreatedBy{v}{v'}}
                  {CBy-19}
    \end{mathpar}
  \caption{Case-related rules of the CreatedBy analysis}
  \end{figure}

  \section{Liveness analysis}

  \begin{figure}[h]

    \begin{mathpar}
		\DatalogRule{\NodeCreatedBy{n}{t}{n'}}
								{\Node{n'}{t} \\\\
								\CreatedBy{v}{v'}}
								{NCBy}
		\and
		\DatalogRule{\PossibleNodeTag{n}{t}}
								{\NodeCreatedBy{n}{t}{\any}}
								{PNT}
		\and
		\DatalogRule{\PossibleAlt{alt}}
								{\AltDefault{\any}{alt}}
								{PA-1}
		\and
		\DatalogRule{\PossibleAlt{alt}}
								{\AltLiteral{\any}{alt}{\any}}
								{PA-2}
		\and
		\DatalogRule{\PossibleAlt{alt}}
								{\Case{r}{scrut} \\\\
								\Alt{r}{alt}{t} \\\\
								\NodeCreatedBy{scrut}{t}{scrut'}}
								{PA-3}
		\and
		\DatalogRule{\PointerOrigin{p}{q}}
								{\Store{q}{\any} \\\\
								\CreatedBy{p}{q}}
								{PO}
		\and
		\DatalogRule{\PossibleLocTag{p}{t}}
								{\Heap{p}{n} \\\\
								\PossibleNodeTag{n}{tag}}
								{PLT}
	  \end{mathpar}
  \caption{Helper relations}
  \end{figure}

  \begin{figure}[h]
    	\begin{mathpar}
      \DatalogRule{\LiveSVal{x}}
                  {\EntryPoint{main} \\\\
                  \ReturnValue{main}{x}}
                  {LS-1}
      \and
      \DatalogRule{\LiveSVal{x}}
                  {\Call{y}{f} \\\\
                  \CallArgument{y}{\any}{x} \\\\
                  \External{f}{true}{\any}}
                  {LS-2}
      \and
      \DatalogRule{\LiveSVal{x}}
              {\LiveSVal{y} \\\\
              \Move{y}{x}}
              {LS-3}
      \and
      % TODO: alt helper relation
      \DatalogRule{\LiveSVal{ret}}
                  {\LiveSVal{res} \\ \PossibleAlt{alt} \\ \ReturnValue{alt}{ret} \\\\
                  (\Alt{res}{alt}{\any} \lor \AltLiteral{res}{alt}{\any} \lor \AltDefault{res}{alt})}
                  {LS-4}
      \and
      \DatalogRule{\LiveSVal{scrut}}
                  {\LiveSVal{alt} \\ \PossibleAlt{alt} \\ \Case{res}{scrut} \\\\
                  (\Alt{res}{alt}{\any} \lor \AltLiteral{res}{alt}{\any} \lor \AltDefault{res}{alt})}
                  {LS-5}
      \and
      \DatalogRule{\LiveFunRetSimple{f}}
                  {\LiveSVal{y} \\\\
                  \Call{y}{f}}
                  {LFS-3}
      \and
      \DatalogRule{\LiveSVal{ret}}
                  {\LiveFunRetSimple{f} \\\\
                  \ReturnValue{f}{ret}}
                  {LS-6}
      \and
      \DatalogRule{\LiveSVal{x}}
                  {\LiveSVal{param} \\\\
                  \FunctionParameter{f}{i}{param} \\\\
                  \Call{y}{f} \\\\
                  \CallArgument{y}{i}{x}}
                  {LS-7}
      \and
      \DatalogRule{\LiveSVal{x}}
                  {\LiveFunRetSimple{f_{ext}} \\\\
                  \External{f_{ext}}{\any}{\any} \\\\
                  \Call{y}{f_{ext}} \\\\
                  \CallArgument{y}{\any}{x}}
                  {LS-8}
      \and
      \DatalogRule{\LiveSVal{x}}
                  {\LiveNodeArg{n}{t}{i} \\\\
                  \Node{n}{t} \\\\
                  \NodeArgument{n}{i}{x}}
                  {LS-9}
	  \end{mathpar}
  \caption{Liveness rules for simple values}
  \end{figure}

  \begin{figure}[h]
    \begin{mathpar}
    \DatalogRule{\LiveNodeArg{n}{t}{i}}
								{\LiveSVal{x} \\\\
								\NodeParameter{as}{i}{x} \\\\
								\NodePattern{as}{t}{n}}
								{LNA-1}
		\and
		\DatalogRule{\LiveNodeArg{n}{t}{i}}
								{\LiveNodeArg{as}{t}{i} \\\\
								\NodePattern{as}{t}{n}}
								{LNA-2}
		\and
		\DatalogRule{\LiveNodeArg{n}{t}{i}}
								{\LiveSVal(x) \\\\
								\NodePattern{as}{t}{n} \\\\
								\NodeParameter{as}{i}{x}}
								{LNA-3}
		\and
		\DatalogRule{\LiveNodeArg{m}{t}{i}}
								{\LiveNodeArg{n}{t}{i} \\\\
								\Move{n}{m}}
								{LNA-4}
    \end{mathpar}
  \caption{Liveness rules for node values}
  \end{figure}

  \begin{figure}[h]
    \begin{mathpar}
    \DatalogRule{\LiveNodeArg{scrut}{t}{i}}
								{\LiveNodeArg{alt}{t}{i} \\\\
								\Case{r}{scrut} \\\\
								\Alt{r}{alt}{t} \\\\
								\AltParameter{r}{t}{i}{\any}}
								{LNA-5}
		\and
		\DatalogRule{\LiveNodeArg{scrut}{t}{i}}
								{\LiveSVal{x} \\\\
								\Case{r}{scrut} \\\\
								\AltParameter{r}{t}{i}{x}}
								{LNA-6}
		\and
		% TODO: maybe NodeCreatedBy?
		\DatalogRule{\LiveNodeArg{ret}{t_{res}}{i}}
								{\LiveNodeArg{res}{t_{res}}{i} \\\\
								\Case{res}{scrut} \\\\
								\Alt{res}{alt}{t_{alt}} \\\\
								\ReturnValue{alt}{ret} \\\\
								\PossibleAlt{alt} \\\\
								\CreatedBy{ret}{ret'} \\\\
								\Node{ret'}{t_{res}}}
								{LNA-7}
		\and
		% TODO: maybe NodeCreatedBy?
		\DatalogRule{\LiveNodeArg{ret}{t_{res}}{i}}
								{\LiveNodeArg{res}{t_{res}}{i} \\\\
								\Case{res}{\any} \\\\
								(\AltLiteral{res}{alt}{\any} \lor \AltDefault{res}{alt}) \\\\
								\ReturnValue{alt}{ret} \\\\
								\CreatedBy{ret}{ret'} \\\\
								\Node{ret'}{t_{res}}}
								{LNA-8}
    \end{mathpar}
  \caption{Liveness rules for case expressions}
  \end{figure}

  \begin{figure}[h]
    \begin{mathpar}
    \DatalogRule{\LiveFunRetNodeArg{f}{t}{i}}
								{\LiveNodeArg{y}{t}{i} \\\\
								\Call{y}{f}}
								{LFN}
		\and
		\DatalogRule{\LiveNodeArg{r}{t}{i}}
								{\LiveFunRetNodeArg{f}{t}{i} \\\\
								\ReturnValue{f}{r}}
								{LNA-9}
		\and
		\DatalogRule{\LiveNodeArg{x}{t}{i}}
								{\LiveNodeArg{param}{t}{i} \\\\
								\FunctionParameter{f}{j}{param} \\\\
								\Call{y}{f} \\\\
								\CallArgument{y}{j}{x}}
								{LNA-10}
    \end{mathpar}
  \caption{Liveness rules for functions}
  \end{figure}

  \begin{figure}[h]
    \begin{mathpar}
    \DatalogRule{\LiveHeapNodeArg{q}{t}{i}}
								{\LiveNodeArg{n}{t}{i} \\\\
								\Fetch{n}{p} \\\\
								\PointerOrigin{p}{q} \\\\
								\PossibleLocTag{q}{t}}
								{LHN}
		\and
		\DatalogRule{\LiveNodeArg{n}{t}{i}}
								{\LiveHeapNodeArg{p}{t}{i} \\\\
								\Store{q}{n} \\\\
								\PointerOrigin{p}{q} \\\\
								\PossibleNodeTag{n}{t}}
								{LNA-11}
		\and
		\DatalogRule{\LiveNodeArg{n}{t}{i}}
								{\LiveHeapNodeArg{q}{t}{i} \\\\
								\Update{\any}{p}{n} \\\\
								\PointerOrigin{p}{q} \\\\
								\PossibleNodeTag{n}{t}}
								{LNA-12}
    \end{mathpar}
  \caption{Liveness rules for heap operations}
  \end{figure}



\end{document}
