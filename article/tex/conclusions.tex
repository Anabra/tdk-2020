\documentclass[main.tex]{subfiles}
\begin{document}
	
	In this paper we presented a modern look at GRIN, an optimizing functional language back end originally published by Urban Bouquist.
	
	We gave an overview of the original GRIN framework, and specified a list of syntactical changes and extensions to the intermediate representation. Then we defined a declarative, relation-based model of the GRIN IR and gave logic-based formalizations for three interprocedural dataflow analyses: the heap points-to analysis, the created-by analysis and the liveness analysis. The model and the analyses were implemented in Datalog. Following that, we detailed the dead data elimination pass. We also presented an extension of the dummification transformation which was made compatible with the new, typed representation of GRIN by extending the IR with the \pilcode{undefined} value. Furthermore, we gave an alternative method for transforming producer-consumer groups by using basic blocks. 
    
    We also briefly outlined the architecture of the Idris front end and the LLVM back end. The latter one required extending the original heap points-to analysis with more accurate basic value tracking. This allowed for defining a type inference algorithm for the GRIN intermediate representation.
    
    Finally, we discussed the related research on compilers utilizing GRIN and whole program optimization.
	
	We evaluated our implementation of GRIN using simple Idris programs taken from the book \textit{Type-driven development with Idris}~\cite{tdd-idris} by Edwin Brady. We measured the optimized GRIN programs, as well as the generated binaries. It is important to note, that the measurements presented in this paper can only be considered preliminary, given the compiler needs further work to be comparable to other systems. Nevertheless, these statistics are still relevant, since they provide valuable information about the effectiveness of the optimizer. The results demonstrate that the GRIN optimizer can significantly improve the performance of GRIN programs. Furthermore, they indicate that the GRIN optimizer performs optimizations orthogonal to the LLVM optimizations, which supports the motivation behind the framework. As for dead data elimination, we found that it can facilitate other transformations during the optimization pipeline, and that it can considerably reduce the size of the generated binaries.
	
	All things considered, the current implementation of GRIN brought adequate results. However, there are still many promising ideas left to research.
	
\end{document}